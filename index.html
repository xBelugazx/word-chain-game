<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì‹¤ì‹œê°„ ëë§ì‡ê¸° ê²Œì„</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans KR', 'Inter', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

    <div id="app" class="w-full max-w-2xl mx-auto bg-white flex flex-col h-screen md:h-auto md:max-h-[95vh] md:my-4 md:rounded-2xl md:shadow-xl">
        
        <div id="loading-screen" class="flex-1 flex items-center justify-center p-8">
            <p class="text-xl text-gray-600">ì—°ê²° ì¤‘ì…ë‹ˆë‹¤...</p>
        </div>

        <div id="lobby-screen" class="hidden p-6 md:p-8 flex flex-col h-full">
            <div class="flex-shrink-0 mb-4">
                <h1 class="text-3xl font-bold text-center text-gray-800">ê²Œì„ ë¡œë¹„ ğŸ®</h1>
                <p class="text-center text-gray-500">ì°¸ì—¬í•  ë°©ì„ ì„ íƒí•˜ê±°ë‚˜ ìƒˆ ë°©ì„ ë§Œë“œì„¸ìš”.</p>
            </div>
            <div class="flex-grow bg-gray-50 rounded-lg p-4 overflow-y-auto custom-scrollbar border">
                <div id="public-rooms-list" class="space-y-2"></div>
            </div>
            <div class="flex-shrink-0 mt-4">
                <button id="open-create-room-modal-btn" class="w-full bg-green-500 text-white font-bold py-3 rounded-lg hover:bg-green-600 transition text-lg">ìƒˆ ë°© ë§Œë“¤ê¸°</button>
            </div>
        </div>

        <div id="game-screen" class="hidden flex-1 flex flex-col p-4 space-y-4 min-h-0">
            <div class="flex-shrink-0 space-y-4">
                <div class="flex justify-between items-center">
                    <button id="leave-room-btn" class="text-sm text-gray-500 hover:text-gray-800">â† ë¡œë¹„ë¡œ ëŒì•„ê°€ê¸°</button>
                    <p id="room-name-display" class="text-2xl font-semibold text-indigo-600"></p>
                    <button id="delete-room-btn" class="hidden text-sm bg-red-100 text-red-700 px-3 py-1 rounded-md hover:bg-red-200">ë°© í­íŒŒ</button>
                </div>
                <div class="flex space-x-4">
                    <div id="game-info" class="flex-1 p-4 bg-gray-50 rounded-lg text-center">
                        <div class="flex justify-center items-center space-x-4">
                             <p class="text-lg">ì œì‹œì–´: <span id="last-word" class="text-4xl font-bold text-blue-600"></span></p>
                             <div class="text-lg">ë‚¨ì€ ì‹œê°„: <span id="timer-display" class="text-4xl font-bold text-red-500">30</span></div>
                        </div>
                        <p id="turn-info" class="text-xl font-medium text-gray-700 h-8 mt-2"></p>
                    </div>
                    <div class="w-1/3 p-4 bg-gray-50 rounded-lg">
                        <h3 class="font-bold text-center mb-2 text-gray-700">ì°¸ê°€ì</h3>
                        <ul id="player-list" class="space-y-1"></ul>
                    </div>
                </div>
            </div>
            
            <div id="word-history" class="flex-grow p-4 bg-gray-100 rounded-lg border overflow-y-auto custom-scrollbar min-h-0">
                <ul id="word-list" class="space-y-3"></ul>
            </div>
            
            <div class="flex-shrink-0 space-y-3">
                 <button id="start-game-btn" class="hidden w-full bg-blue-500 text-white font-bold py-3 rounded-lg hover:bg-blue-600">ê²Œì„ ì‹œì‘</button>
                <div class="flex items-center space-x-3">
                    <input type="text" id="word-input" placeholder="ë‹¨ì–´ë¥¼ ì…ë ¥..." class="flex-grow w-full px-4 py-3 border rounded-lg text-lg" disabled>
                    <button id="send-btn" class="bg-blue-500 text-white font-bold px-6 py-3 rounded-lg text-lg" disabled>ì „ì†¡</button>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <button id="forfeit-btn" class="w-full bg-gray-200 text-gray-700 font-bold py-3 rounded-lg hover:bg-gray-300">í•­ë³µ</button>
                    <button id="reset-game-btn" class="w-full bg-yellow-500 text-yellow-800 font-bold py-3 rounded-lg hover:bg-yellow-600">ë‹¤ì‹œ í•˜ê¸°</button>
                </div>
            </div>
        </div>
    </div>

    <div id="create-room-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md space-y-4">
            <h2 class="text-2xl font-bold">ìƒˆ ë°© ë§Œë“¤ê¸°</h2>
            <input type="text" id="nickname-input" placeholder="ë‹‰ë„¤ì„" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <input type="text" id="room-name-input" placeholder="ë°© ì´ë¦„" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <input type="password" id="password-input" placeholder="ë¹„ë°€ë²ˆí˜¸ (ì—†ìœ¼ë©´ ê³µê°œ ë°©)" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <div>
                <label for="max-players-input" class="text-sm font-medium text-gray-700">ìµœëŒ€ ì¸ì› (2~10ëª…)</label>
                <input type="number" id="max-players-input" value="4" min="2" max="10" class="w-full mt-1 px-4 py-3 border rounded-lg bg-white">
            </div>
            <div class="flex justify-end space-x-4">
                <button id="cancel-create-btn" class="px-4 py-2 rounded hover:bg-gray-100">ì·¨ì†Œ</button>
                <button id="confirm-create-btn" class="px-4 py-2 rounded bg-green-500 text-white hover:bg-green-600">ë§Œë“¤ê¸°</button>
            </div>
        </div>
    </div>
    <div id="password-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md space-y-4">
            <h2 class="text-2xl font-bold">ë¹„ë°€ë²ˆí˜¸ ì…ë ¥</h2>
            <input type="text" id="join-nickname-input" placeholder="ë‹‰ë„¤ì„" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <input type="password" id="join-password-input" placeholder="ë¹„ë°€ë²ˆí˜¸" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <div class="flex justify-end space-x-4">
                <button id="cancel-join-btn" class="px-4 py-2 rounded hover:bg-gray-100">ì·¨ì†Œ</button>
                <button id="confirm-join-btn" class="px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600">ì°¸ì—¬í•˜ê¸°</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, collection, query, where, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const allDOMElements = {
            loadingScreen: document.getElementById('loading-screen'), lobbyScreen: document.getElementById('lobby-screen'), gameScreen: document.getElementById('game-screen'),
            publicRoomsList: document.getElementById('public-rooms-list'), openCreateRoomModalBtn: document.getElementById('open-create-room-modal-btn'),
            leaveRoomBtn: document.getElementById('leave-room-btn'), deleteRoomBtn: document.getElementById('delete-room-btn'),
            createRoomModal: document.getElementById('create-room-modal'), passwordModal: document.getElementById('password-modal'),
            nicknameInput: document.getElementById('nickname-input'), roomNameInput: document.getElementById('room-name-input'), passwordInput: document.getElementById('password-input'),
            maxPlayersInput: document.getElementById('max-players-input'),
            cancelCreateBtn: document.getElementById('cancel-create-btn'), confirmCreateBtn: document.getElementById('confirm-create-btn'),
            joinNicknameInput: document.getElementById('join-nickname-input'), joinPasswordInput: document.getElementById('join-password-input'),
            cancelJoinBtn: document.getElementById('cancel-join-btn'), confirmJoinBtn: document.getElementById('confirm-join-btn'),
            roomNameDisplay: document.getElementById('room-name-display'), lastWordEl: document.getElementById('last-word'),
            turnInfoEl: document.getElementById('turn-info'), timerDisplay: document.getElementById('timer-display'),
            wordListEl: document.getElementById('word-list'), wordInput: document.getElementById('word-input'),
            sendBtn: document.getElementById('send-btn'), resetGameBtn: document.getElementById('reset-game-btn'),
            forfeitBtn: document.getElementById('forfeit-btn'), playerList: document.getElementById('player-list'),
            startGameBtn: document.getElementById('start-game-btn'),
        };

        const firebaseConfig = {
          apiKey: "AIzaSyC4NyJ4kTK4VTrFBaIWsBUWtcaSK21KBBg",
          authDomain: "my-word-game-510f9.firebaseapp.com",
          projectId: "my-word-game-510f9",
          storageBucket: "my-word-game-510f9.firebasestorage.app",
          messagingSenderId: "766315896698",
          appId: "1:766315896698:web:cd32a3ac30e85292a8c0c3"
        };
        const appId = firebaseConfig.projectId;
        let app, db, auth, userId, currentGameId;
        let unsubscribeGame = null, unsubscribeRooms = null, timerInterval = null;

        const TURN_DURATION = 30;
        const dueumMap = { 'ë¼': 'ë‚˜', 'ë½': 'ë‚™', 'ë€': 'ë‚œ', 'ë„': 'ë‚ ', 'ëŒ': 'ë‚¨', 'ë': 'ë‚©', 'ë‘': 'ë‚­', 'ë˜': 'ë‚´', 'ë­': 'ëƒ‰', 'ëŸ‰': 'ì–‘', 'ë ¤': 'ì—¬', 'ë ¥': 'ì—­', 'ë ¨': 'ì—°', 'ë ¬': 'ì—´', 'ë ´': 'ì—¼', 'ë µ': 'ì—½', 'ë ¹': 'ì˜', 'ë¡€': 'ì˜ˆ', 'ë¡œ': 'ë…¸', 'ë¡': 'ë…¹', 'ë¡ ': 'ë…¼', 'ë¡±': 'ë†', 'ë¢°': 'ë‡Œ', 'ë£Œ': 'ìš”', 'ë£¡': 'ìš©', 'ë£¨': 'ëˆ„', 'ë‰´': 'ìœ ', 'ë‹ˆ': 'ì´', 'ë…€': 'ì—¬', 'ë‡¨': 'ìš”' };

        async function main() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                onAuthStateChanged(auth, (user) => {
                    if (user) { userId = user.uid; showLobby(); } else { signInAnonymously(auth); }
                });
            } catch (error) {
                console.error("Firebase ì´ˆê¸°í™” ì˜¤ë¥˜:", error);
                allDOMElements.loadingScreen.textContent = "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
            }
        }

        function showLobby() {
            allDOMElements.loadingScreen.classList.add('hidden');
            allDOMElements.gameScreen.classList.add('hidden');
            allDOMElements.lobbyScreen.classList.remove('hidden');
            listenToPublicRooms();
        }

        function showGame(roomId) {
            allDOMElements.lobbyScreen.classList.add('hidden');
            allDOMElements.gameScreen.classList.remove('hidden');
            allDOMElements.roomNameDisplay.textContent = roomId;
        }

        function listenToPublicRooms() {
            if (unsubscribeRooms) unsubscribeRooms();
            const roomsRef = collection(db, `artifacts/${appId}/public/data/games`);
            const q = query(roomsRef, where("status", "==", "waiting"));

            unsubscribeRooms = onSnapshot(q, (querySnapshot) => {
                allDOMElements.publicRoomsList.innerHTML = '';
                if (querySnapshot.empty) {
                    allDOMElements.publicRoomsList.innerHTML = `<p class="text-gray-500 text-center">ì°¸ì—¬í•  ìˆ˜ ìˆëŠ” ë°©ì´ ì—†ìŠµë‹ˆë‹¤.</p>`;
                }
                querySnapshot.forEach((docSnap) => {
                    const room = docSnap.data();
                    const roomEl = document.createElement('div');
                    roomEl.className = 'p-4 bg-white rounded-lg shadow flex justify-between items-center cursor-pointer hover:bg-gray-50';
                    roomEl.dataset.roomId = docSnap.id;
                    roomEl.dataset.passwordProtected = !!room.password;
                    
                    roomEl.innerHTML = `
                        <div>
                            <p class="font-bold text-lg">${docSnap.id}</p>
                            <p class="text-sm text-gray-600">${Object.keys(room.players || {}).length} / ${room.maxPlayers} ëª…</p>
                        </div>
                        ${room.password ? '<span>ğŸ”’</span>' : ''}
                    `;
                    allDOMElements.publicRoomsList.appendChild(roomEl);
                });
            });
        }

        async function createRoom(nickname, roomName, password, maxPlayers) {
            if (!nickname || !roomName) return alert("ë‹‰ë„¤ì„ê³¼ ë°© ì´ë¦„ì„ ëª¨ë‘ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, roomName);
            if ((await getDoc(gameDocRef)).exists()) return alert("ì´ë¯¸ ì¡´ì¬í•˜ëŠ” ë°© ì´ë¦„ì…ë‹ˆë‹¤.");

            await setDoc(gameDocRef, {
                creatorUid: userId, players: { [userId]: { nickname } },
                words: [], lastWord: "", currentPlayerUid: null, turnOrder: [],
                status: 'waiting', isPublic: !password, password: password || null,
                turnStartTime: serverTimestamp(), maxPlayers: parseInt(maxPlayers, 10),
            });
            startListeningToGame(gameDocRef, roomName);
        }

        async function joinRoom(roomId, nickname, passwordAttempt = null) {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, roomId);
            const docSnap = await getDoc(gameDocRef);
            if (!docSnap.exists()) return alert("ì¡´ì¬í•˜ì§€ ì•ŠëŠ” ë°©ì…ë‹ˆë‹¤.");

            const gameData = docSnap.data();
            if (gameData.password && gameData.password !== passwordAttempt) return alert("ë¹„ë°€ë²ˆí˜¸ê°€ í‹€ë ¸ìŠµë‹ˆë‹¤.");
            
            const playerCount = Object.keys(gameData.players || {}).length;
            if (playerCount >= gameData.maxPlayers && !gameData.players[userId]) return alert("ë°©ì´ ê°€ë“ ì°¼ìŠµë‹ˆë‹¤.");
            
            const updateData = { [`players.${userId}`]: { nickname } };
            const newPlayerCount = playerCount + (gameData.players[userId] ? 0 : 1);

            if (newPlayerCount === gameData.maxPlayers) {
                const playerIds = [...Object.keys(gameData.players || {}), userId];
                const shuffledPlayerIds = playerIds.sort(() => Math.random() - 0.5);
                updateData.status = 'playing';
                updateData.turnOrder = shuffledPlayerIds;
                updateData.currentPlayerUid = shuffledPlayerIds[0];
                updateData.turnStartTime = serverTimestamp();
            }
            
            await updateDoc(gameDocRef, updateData);
            allDOMElements.passwordModal.classList.add('hidden');
            startListeningToGame(gameDocRef, roomId);
        }

        function startListeningToGame(gameDocRef, roomId) {
            if (unsubscribeRooms) unsubscribeRooms();
            if (unsubscribeGame) unsubscribeGame();
            currentGameId = roomId;

            unsubscribeGame = onSnapshot(gameDocRef, (docSnap) => {
                if (docSnap.exists()) { updateUI(docSnap.data()); } 
                else { alert("ë°©ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤."); leaveRoom(true); }
            });
            showGame(roomId);
        }
        
        async function leaveRoom(isKicked = false) {
            const roomId = currentGameId;
            if (unsubscribeGame) unsubscribeGame();
            unsubscribeGame = null;
            currentGameId = null;
            if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
            
            if (roomId && !isKicked) {
                try {
                    const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, roomId);
                    const docSnap = await getDoc(gameDocRef);
                    if (docSnap.exists()) {
                        const gameData = docSnap.data();
                        const players = { ...(gameData.players || {}) };
                        const turnOrder = gameData.turnOrder || [];
                        const creatorUid = gameData.creatorUid;
                        const currentPlayerUid = gameData.currentPlayerUid;
                        const leavingPlayerIndex = turnOrder.indexOf(userId);
                        
                        // 1) í”Œë ˆì´ì–´ ì œê±°
                        delete players[userId];
                        const newTurnOrder = turnOrder.filter(p => p !== userId);

                        // 2) ë°©ì— ì•„ë¬´ë„ ì—†ìœ¼ë©´ ì‚­ì œ
                        if (Object.keys(players).length === 0) {
                            await deleteDoc(gameDocRef);
                        } else {
                            // 3) ë‹¤ìŒ í„´ì ê²°ì •: ë§Œì•½ ë– ë‚˜ëŠ” ì‚¬ëŒì´ í˜„ì¬ í„´ì´ë©´ ë‹¤ìŒ ì‚¬ëŒìœ¼ë¡œ ì˜®ê¹€
                            let nextPlayerUid = currentPlayerUid;
                            if (currentPlayerUid === userId) {
                                if (newTurnOrder.length > 0) {
                                    nextPlayerUid = newTurnOrder[leavingPlayerIndex % newTurnOrder.length];
                                } else {
                                    nextPlayerUid = Object.keys(players)[0];
                                }
                            }

                            // 4) ë°©ì¥ ë– ë‚¨ ì²˜ë¦¬: ë°©ì¥ uidë¥¼ ìƒˆ í”Œë ˆì´ì–´ë¡œ ì§€ì • (ê°„ë‹¨í•˜ê²Œ ì²« í”Œë ˆì´ì–´)
                            let newCreator = creatorUid;
                            if (creatorUid === userId) {
                                newCreator = Object.keys(players)[0];
                            }

                            await updateDoc(gameDocRef, { 
                                players, 
                                turnOrder: newTurnOrder,
                                creatorUid: newCreator,
                                status: 'waiting', 
                                words: [], 
                                lastWord: "", 
                                currentPlayerUid: nextPlayerUid
                            });
                        }
                    }
                } catch (error) { console.error("Error leaving room:", error); }
            }
            showLobby();
        }

        function updateUI(gameData) {
            if (!gameData) return;
            const { players = {}, currentPlayerUid, words = [], lastWord = "", status, creatorUid, turnOrder = [], turnStartTime, winner, maxPlayers } = gameData;
            
            allDOMElements.deleteRoomBtn.classList.toggle('hidden', creatorUid !== userId);
            updatePlayerList(players, turnOrder, currentPlayerUid);

            const canStart = creatorUid === userId && Object.keys(players).length >= 2;
            allDOMElements.startGameBtn.classList.toggle('hidden', !canStart || status === 'playing');

            if (status === 'waiting') {
                allDOMElements.turnInfoEl.textContent = `ìƒëŒ€ë°©ì„ ê¸°ë‹¤ë¦¬ëŠ” ì¤‘ì…ë‹ˆë‹¤... (${Object.keys(players).length}/${maxPlayers})`;
                allDOMElements.lastWordEl.textContent = "ëŒ€ê¸°ì¤‘";
                allDOMElements.timerDisplay.textContent = TURN_DURATION;
                allDOMElements.wordInput.disabled = true;
                allDOMElements.sendBtn.disabled = true;
                allDOMElements.forfeitBtn.disabled = true;
                allDOMElements.resetGameBtn.disabled = true;
                return;
            }
            
            const isMyTurn = currentPlayerUid === userId;
            allDOMElements.wordListEl.innerHTML = '';
            words.forEach(item => {
                const li = document.createElement('li');
                const nickname = players[item.player]?.nickname || 'ì•Œìˆ˜ì—†ìŒ';
                const isMyMessage = item.player === userId;
                li.className = `p-3 rounded-lg ${isMyMessage ? 'bg-blue-50 text-right' : 'bg-green-50 text-left'}`;
                li.innerHTML = `<span class="font-bold ${isMyMessage ? 'text-blue-600' : 'text-green-600'}">${nickname}</span>: <span class="text-xl text-gray-800">${item.word}</span>`;
                allDOMElements.wordListEl.appendChild(li);
            });
            allDOMElements.wordListEl.scrollTop = allDOMElements.wordListEl.scrollHeight;
            
            if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

            if (status === 'finished') {
                const winnerNickname = players[winner.uid]?.nickname;
                allDOMElements.turnInfoEl.textContent = `${winnerNickname}ë‹˜ì˜ ìŠ¹ë¦¬! (${winner.reason})`;
                allDOMElements.lastWordEl.textContent = "ê²Œì„ ì¢…ë£Œ";
                allDOMElements.wordInput.disabled = true;
                allDOMElements.sendBtn.disabled = true;
                allDOMElements.forfeitBtn.disabled = true;
                allDOMElements.resetGameBtn.disabled = !(creatorUid === userId);
                allDOMElements.resetGameBtn.textContent = "ë‹¤ì‹œ í•˜ê¸°";
                return;
            }

            const currentPlayerNickname = players[currentPlayerUid]?.nickname;
            allDOMElements.forfeitBtn.disabled = false;
            allDOMElements.resetGameBtn.disabled = true;
            allDOMElements.resetGameBtn.textContent = "ê²Œì„ ì´ˆê¸°í™”";

            if (words.length === 0) {
                allDOMElements.lastWordEl.textContent = "ê²Œì„ ì‹œì‘!";
                allDOMElements.turnInfoEl.textContent = isMyTurn ? `${players[userId].nickname}ë‹˜, ì²« ë‹¨ì–´ë¥¼ ì œì‹œí•´ì£¼ì„¸ìš”!` : `${currentPlayerNickname}ë‹˜ì´ ì²« ë‹¨ì–´ë¥¼ ì œì‹œí•©ë‹ˆë‹¤...`;
            } else {
                allDOMElements.lastWordEl.textContent = lastWord;
                allDOMElements.turnInfoEl.textContent = isMyTurn ? `${players[userId].nickname}ë‹˜ ì°¨ë¡€ì…ë‹ˆë‹¤!` : `${currentPlayerNickname}ë‹˜ ì°¨ë¡€ì…ë‹ˆë‹¤...`;
            }
            allDOMElements.wordInput.disabled = !isMyTurn;
            allDOMElements.sendBtn.disabled = !isMyTurn;
            if (isMyTurn) {
                // í¬ì»¤ìŠ¤ ì‹œë„ (ë¹„í™œì„±í™” ìƒíƒœê°€ ì•„ë‹ ë•Œë§Œ)
                setTimeout(() => { 
                    try { allDOMElements.wordInput.focus(); } catch(e) { /* ignore */ } 
                }, 50);
            }

            if(turnStartTime && turnStartTime.toDate) {
                const startTime = turnStartTime.toDate().getTime();
                timerInterval = setInterval(async () => {
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    const remaining = TURN_DURATION - elapsed;
                    allDOMElements.timerDisplay.textContent = remaining >= 0 ? remaining : 0;
                    if (remaining < 0 && isMyTurn) {
                        clearInterval(timerInterval);
                        const otherPlayers = Object.keys(players).filter(p => p !== userId);
                        const winnerUid = otherPlayers.length >= 1 ? otherPlayers[0] : userId;
                        await endGame(winnerUid, "ì‹œê°„ ì´ˆê³¼");
                    }
                }, 1000);
            }
        }
        
        function updatePlayerList(players, turnOrder, currentPlayerUid) {
             allDOMElements.playerList.innerHTML = '';
            const playerIdsInTurnOrder = turnOrder && turnOrder.length > 0 ? turnOrder : Object.keys(players);
            playerIdsInTurnOrder.forEach(pid => {
                if (!players[pid]) return;
                const li = document.createElement('li');
                const isCurrent = pid === currentPlayerUid;
                li.className = `p-2 rounded-md truncate ${isCurrent ? 'bg-blue-100 font-bold text-blue-700' : 'bg-gray-100'}`;
                li.textContent = players[pid]?.nickname || '...';
                allDOMElements.playerList.appendChild(li);
            });
        }
        
        async function endGame(winnerUid, reason) {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            await updateDoc(gameDocRef, { status: 'finished', winner: { uid: winnerUid, reason: reason } });
        }
        
        async function handleSendWord() {
            const word = allDOMElements.wordInput.value.trim();
            if (!word || word.length < 2) return alert("ë‘ ê¸€ì ì´ìƒì˜ ë‹¨ì–´ë¥¼ ì…ë ¥í•´ì£¼ì„¸ìš”.");
            allDOMElements.sendBtn.disabled = true;

            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            const gameDoc = await getDoc(gameDocRef);

            if (gameDoc.exists()) {
                const gameData = gameDoc.data();
                const { words = [], lastWord = "", turnOrder = [] } = gameData;
                const lastChar = lastWord.charAt(lastWord.length - 1);
                const firstChar = word.charAt(0);

                const isValidDueum = dueumMap[lastChar] === firstChar;
                if (words.length > 0 && lastChar !== firstChar && !isValidDueum) {
                    allDOMElements.sendBtn.disabled = false;
                    return alert("ì´ì „ ë‹¨ì–´ì˜ ë§ˆì§€ë§‰ ê¸€ìë¡œ ì‹œì‘í•´ì•¼ í•©ë‹ˆë‹¤.");
                }
                if (words.some(item => item.word === word)) {
                    allDOMElements.sendBtn.disabled = false;
                    return alert("ì´ë¯¸ ì‚¬ìš©ëœ ë‹¨ì–´ì…ë‹ˆë‹¤.");
                }
                const isValidWord = await isRealWord(word);
                if (!isValidWord) {
                    allDOMElements.sendBtn.disabled = false;
                    return alert(`'${word}'ëŠ” ì‚¬ì „ì— ì—†ëŠ” ë‹¨ì–´ì…ë‹ˆë‹¤.`);
                }

                const currentIndex = turnOrder.indexOf(userId);
                const nextIndex = (currentIndex + 1) % turnOrder.length;
                const nextPlayerUid = turnOrder[nextIndex];
                
                await updateDoc(gameDocRef, {
                    words: [...words, { player: userId, word: word }],
                    lastWord: word,
                    currentPlayerUid: nextPlayerUid,
                    turnStartTime: serverTimestamp()
                });
                allDOMElements.wordInput.value = '';
            }
            allDOMElements.sendBtn.disabled = false;
        }

        // (ì£¼ì˜) ì‹¤ì œ ë°°í¬ ì‹œì—ëŠ” API í‚¤ë¥¼ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•˜ì„¸ìš”.
        async function isRealWord(word) {
            // ì™¸ë¶€ API ì‚¬ìš© ë¶€ë¶„ì€ ì„ì‹œë¡œ trueë¥¼ ë°˜í™˜í•˜ë„ë¡ ë‘ì—ˆìŠµë‹ˆë‹¤.
            // ì‹¤ì œë¡œ í‘œì¤€êµ­ì–´ëŒ€ì‚¬ì „ ë“±ê³¼ ì—°ë™í•˜ë ¤ë©´ ì„œë²„ ì¸¡ì—ì„œ API í˜¸ì¶œì„ êµ¬í˜„í•˜ì„¸ìš”.
            return true;
        }

        // --- IME ì¡°í•© ë¬¸ì œ í•´ê²°: composition ì´ë²¤íŠ¸ ì²˜ë¦¬ ---
        (function setupCompositionSafeInput() {
            const input = allDOMElements.wordInput;
            let composing = false;
            input.addEventListener('compositionstart', () => { composing = true; });
            input.addEventListener('compositionend', (e) => {
                composing = false;
                // ì¡°í•©ì´ ëë‚œ ë’¤ í•„í„°ë§ ì ìš© (í•œê¸€ê³¼ ê³µë°±ë§Œ í—ˆìš©)
                e.target.value = e.target.value.replace(/[^ê°€-í£\s]/g, '');
            });
            input.addEventListener('input', (e) => {
                // ì¡°í•© ì¤‘ì´ë©´ í•„í„°ë§ì„ ì ìš©í•˜ì§€ ì•ŠìŒ -> IME ì…ë ¥ì´ ì •ìƒì ìœ¼ë¡œ ë³´ì„
                if (composing) return;
                e.target.value = e.target.value.replace(/[^ê°€-í£\s]/g, '');
            });
        })();

        allDOMElements.openCreateRoomModalBtn.addEventListener('click', () => allDOMElements.createRoomModal.classList.remove('hidden'));
        allDOMElements.cancelCreateBtn.addEventListener('click', () => allDOMElements.createRoomModal.classList.add('hidden'));
        allDOMElements.confirmCreateBtn.addEventListener('click', () => {
            createRoom(
                allDOMElements.nicknameInput.value.trim(), 
                allDOMElements.roomNameInput.value.trim(), 
                allDOMElements.passwordInput.value.trim(),
                allDOMElements.maxPlayersInput.value
            );
            allDOMElements.createRoomModal.classList.add('hidden');
        });
        
        allDOMElements.publicRoomsList.addEventListener('click', (e) => {
            const roomEl = e.target.closest('[data-room-id]');
            if (!roomEl) return;
            const { roomId, passwordProtected } = roomEl.dataset;
            allDOMElements.passwordModal.dataset.roomId = roomId;
            if (passwordProtected === 'true') {
                allDOMElements.joinNicknameInput.value = '';
                allDOMElements.joinPasswordInput.value = '';
                allDOMElements.passwordModal.classList.remove('hidden');
            } else {
                const nickname = prompt("ì‚¬ìš©í•  ë‹‰ë„¤ì„ì„ ì…ë ¥í•˜ì„¸ìš”:");
                if(nickname) joinRoom(roomId, nickname);
            }
        });
        
        allDOMElements.cancelJoinBtn.addEventListener('click', () => allDOMElements.passwordModal.classList.add('hidden'));
        allDOMElements.confirmJoinBtn.addEventListener('click', () => {
            const roomId = allDOMElements.passwordModal.dataset.roomId;
            const nickname = allDOMElements.joinNicknameInput.value.trim();
            const password = allDOMElements.joinPasswordInput.value.trim();
            if(nickname) joinRoom(roomId, nickname, password);
        });

        allDOMElements.leaveRoomBtn.addEventListener('click', () => leaveRoom(false));
        allDOMElements.deleteRoomBtn.addEventListener('click', async () => {
            if (confirm("ì •ë§ë¡œ ì´ ë°©ì„ ì‚­ì œí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                await deleteDoc(doc(db, `artifacts/${appId}/public/data/games`, currentGameId));
            }
        });
        
        allDOMElements.sendBtn.addEventListener('click', handleSendWord);
        allDOMElements.wordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSendWord(); });
        
        allDOMElements.forfeitBtn.addEventListener('click', async () => {
            if (confirm("ì •ë§ë¡œ í•­ë³µí•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) {
                const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                const gameDoc = await getDoc(gameDocRef);
                if(gameDoc.exists()) {
                    const otherPlayers = Object.keys(gameDoc.data().players || {}).filter(p => p !== userId);
                    if (otherPlayers.length > 0) {
                        await endGame(otherPlayers[0], "í•­ë³µ");
                    }
                }
            }
        });
        
        allDOMElements.resetGameBtn.addEventListener('click', async () => {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            const gameDoc = await getDoc(gameDocRef);
            if(gameDoc.exists()){
                const gameData = gameDoc.data();
                if (gameData.creatorUid !== userId) return alert("ë°©ì¥ë§Œ ê²Œì„ì„ ë‹¤ì‹œ ì‹œì‘í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.");
                if (gameData.status !== 'finished') {
                    if (!confirm("ê²Œì„ì´ ì§„í–‰ì¤‘ì…ë‹ˆë‹¤. ì •ë§ë¡œ ì´ˆê¸°í™”í•˜ì‹œê² ìŠµë‹ˆê¹Œ?")) return;
                }
                const playerIds = Object.keys(gameData.players || {});
                const shuffledPlayerIds = playerIds.sort(() => Math.random() - 0.5);
                await updateDoc(gameDocRef, {
                    words: [], lastWord: "", status: 'playing',
                    turnOrder: shuffledPlayerIds,
                    currentPlayerUid: shuffledPlayerIds[0],
                    turnStartTime: serverTimestamp(),
                    winner: null
                });
            }
        });

        allDOMElements.startGameBtn.addEventListener('click', async () => {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            const docSnap = await getDoc(gameDocRef);
            if (docSnap.exists()) {
                const gameData = docSnap.data();
                const playerIds = Object.keys(gameData.players || {});
                const shuffledPlayerIds = playerIds.sort(() => Math.random() - 0.5);
                await updateDoc(gameDocRef, {
                    status: 'playing',
                    turnOrder: shuffledPlayerIds,
                    currentPlayerUid: shuffledPlayerIds[0],
                    turnStartTime: serverTimestamp()
                });
            }
        });

        main();
    </script>
</body>
</html>
