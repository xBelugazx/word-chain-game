<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>실시간 끝말잇기 게임</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Noto+Sans+KR:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Noto Sans KR', 'Inter', sans-serif; }
        .custom-scrollbar::-webkit-scrollbar { width: 8px; }
        .custom-scrollbar::-webkit-scrollbar-track { background: #f1f1f1; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb { background: #888; border-radius: 10px; }
        .custom-scrollbar::-webkit-scrollbar-thumb:hover { background: #555; }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen">

    <div id="app" class="w-full max-w-2xl mx-auto bg-white flex flex-col h-screen md:h-auto md:max-h-[95vh] md:my-4 md:rounded-2xl md:shadow-xl">
        
        <div id="loading-screen" class="flex-1 flex items-center justify-center p-8">
            <p class="text-xl text-gray-600">연결 중입니다...</p>
        </div>

        <div id="lobby-screen" class="hidden p-6 md:p-8 flex flex-col h-full">
            <div class="flex-shrink-0 mb-4">
                <h1 class="text-3xl font-bold text-center text-gray-800">게임 로비 🎮</h1>
                <p class="text-center text-gray-500">참여할 방을 선택하거나 새 방을 만드세요.</p>
            </div>
            <div class="flex-grow bg-gray-50 rounded-lg p-4 overflow-y-auto custom-scrollbar border">
                <div id="public-rooms-list" class="space-y-2"></div>
            </div>
            <div class="flex-shrink-0 mt-4">
                <button id="open-create-room-modal-btn" class="w-full bg-green-500 text-white font-bold py-3 rounded-lg hover:bg-green-600 transition text-lg">새 방 만들기</button>
            </div>
        </div>

        <div id="game-screen" class="hidden flex-1 flex flex-col p-4 space-y-4 min-h-0">
            <div class="flex-shrink-0 space-y-4">
                <div class="flex justify-between items-center">
                    <button id="leave-room-btn" class="text-sm text-gray-500 hover:text-gray-800">← 로비로 돌아가기</button>
                    <p id="room-name-display" class="text-2xl font-semibold text-indigo-600"></p>
                    <button id="delete-room-btn" class="hidden text-sm bg-red-100 text-red-700 px-3 py-1 rounded-md hover:bg-red-200">방 폭파</button>
                </div>
                <div class="flex space-x-4">
                    <div id="game-info" class="flex-1 p-4 bg-gray-50 rounded-lg text-center">
                        <div class="flex justify-center items-center space-x-4">
                             <p class="text-lg">제시어: <span id="last-word" class="text-4xl font-bold text-blue-600"></span></p>
                             <div class="text-lg">남은 시간: <span id="timer-display" class="text-4xl font-bold text-red-500">30</span></div>
                        </div>
                        <p id="turn-info" class="text-xl font-medium text-gray-700 h-8 mt-2"></p>
                    </div>
                    <div class="w-1/3 p-4 bg-gray-50 rounded-lg">
                        <h3 class="font-bold text-center mb-2 text-gray-700">참가자</h3>
                        <ul id="player-list" class="space-y-1"></ul>
                    </div>
                </div>
            </div>
            
            <div id="word-history" class="flex-grow p-4 bg-gray-100 rounded-lg border overflow-y-auto custom-scrollbar min-h-0">
                <ul id="word-list" class="space-y-3"></ul>
            </div>
            
            <div class="flex-shrink-0 space-y-3">
                 <button id="start-game-btn" class="hidden w-full bg-blue-500 text-white font-bold py-3 rounded-lg hover:bg-blue-600">게임 시작</button>
                <div class="flex items-center space-x-3">
                    <input type="text" id="word-input" placeholder="단어를 입력..." class="flex-grow w-full px-4 py-3 border rounded-lg text-lg" disabled>
                    <button id="send-btn" class="bg-blue-500 text-white font-bold px-6 py-3 rounded-lg text-lg" disabled>전송</button>
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <button id="forfeit-btn" class="w-full bg-gray-200 text-gray-700 font-bold py-3 rounded-lg hover:bg-gray-300">항복</button>
                    <button id="reset-game-btn" class="w-full bg-yellow-500 text-yellow-800 font-bold py-3 rounded-lg hover:bg-yellow-600">다시 하기</button>
                </div>
            </div>
        </div>
    </div>

    <div id="create-room-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md space-y-4">
            <h2 class="text-2xl font-bold">새 방 만들기</h2>
            <input type="text" id="nickname-input" placeholder="닉네임" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <input type="text" id="room-name-input" placeholder="방 이름" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <input type="password" id="password-input" placeholder="비밀번호 (없으면 공개 방)" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <div>
                <label for="max-players-input" class="text-sm font-medium text-gray-700">최대 인원 (2~10명)</label>
                <input type="number" id="max-players-input" value="4" min="2" max="10" class="w-full mt-1 px-4 py-3 border rounded-lg bg-white">
            </div>
            <div class="flex justify-end space-x-4">
                <button id="cancel-create-btn" class="px-4 py-2 rounded hover:bg-gray-100">취소</button>
                <button id="confirm-create-btn" class="px-4 py-2 rounded bg-green-500 text-white hover:bg-green-600">만들기</button>
            </div>
        </div>
    </div>
    <div id="password-modal" class="hidden fixed inset-0 bg-gray-600 bg-opacity-50 flex items-center justify-center">
        <div class="bg-white p-8 rounded-lg shadow-xl w-full max-w-md space-y-4">
            <h2 class="text-2xl font-bold">비밀번호 입력</h2>
            <input type="text" id="join-nickname-input" placeholder="닉네임" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <input type="password" id="join-password-input" placeholder="비밀번호" class="w-full px-4 py-3 border rounded-lg" autocomplete="off">
            <div class="flex justify-end space-x-4">
                <button id="cancel-join-btn" class="px-4 py-2 rounded hover:bg-gray-100">취소</button>
                <button id="confirm-join-btn" class="px-4 py-2 rounded bg-blue-500 text-white hover:bg-blue-600">참여하기</button>
            </div>
        </div>
    </div>

    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, getDoc, setDoc, onSnapshot, updateDoc, collection, query, where, deleteDoc, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        const allDOMElements = {
            loadingScreen: document.getElementById('loading-screen'), lobbyScreen: document.getElementById('lobby-screen'), gameScreen: document.getElementById('game-screen'),
            publicRoomsList: document.getElementById('public-rooms-list'), openCreateRoomModalBtn: document.getElementById('open-create-room-modal-btn'),
            leaveRoomBtn: document.getElementById('leave-room-btn'), deleteRoomBtn: document.getElementById('delete-room-btn'),
            createRoomModal: document.getElementById('create-room-modal'), passwordModal: document.getElementById('password-modal'),
            nicknameInput: document.getElementById('nickname-input'), roomNameInput: document.getElementById('room-name-input'), passwordInput: document.getElementById('password-input'),
            maxPlayersInput: document.getElementById('max-players-input'),
            cancelCreateBtn: document.getElementById('cancel-create-btn'), confirmCreateBtn: document.getElementById('confirm-create-btn'),
            joinNicknameInput: document.getElementById('join-nickname-input'), joinPasswordInput: document.getElementById('join-password-input'),
            cancelJoinBtn: document.getElementById('cancel-join-btn'), confirmJoinBtn: document.getElementById('confirm-join-btn'),
            roomNameDisplay: document.getElementById('room-name-display'), lastWordEl: document.getElementById('last-word'),
            turnInfoEl: document.getElementById('turn-info'), timerDisplay: document.getElementById('timer-display'),
            wordListEl: document.getElementById('word-list'), wordInput: document.getElementById('word-input'),
            sendBtn: document.getElementById('send-btn'), resetGameBtn: document.getElementById('reset-game-btn'),
            forfeitBtn: document.getElementById('forfeit-btn'), playerList: document.getElementById('player-list'),
            startGameBtn: document.getElementById('start-game-btn'),
        };

        const firebaseConfig = {
          apiKey: "AIzaSyC4NyJ4kTK4VTrFBaIWsBUWtcaSK21KBBg",
          authDomain: "my-word-game-510f9.firebaseapp.com",
          projectId: "my-word-game-510f9",
          storageBucket: "my-word-game-510f9.firebasestorage.app",
          messagingSenderId: "766315896698",
          appId: "1:766315896698:web:cd32a3ac30e85292a8c0c3"
        };
        const appId = firebaseConfig.projectId;
        let app, db, auth, userId, currentGameId;
        let unsubscribeGame = null, unsubscribeRooms = null, timerInterval = null;

        const TURN_DURATION = 30;
        const dueumMap = { '라': '나', '락': '낙', '란': '난', '랄': '날', '람': '남', '랍': '납', '랑': '낭', '래': '내', '랭': '냉', '량': '양', '려': '여', '력': '역', '련': '연', '렬': '열', '렴': '염', '렵': '엽', '령': '영', '례': '예', '로': '노', '록': '녹', '론': '논', '롱': '농', '뢰': '뇌', '료': '요', '룡': '용', '루': '누', '뉴': '유', '니': '이', '녀': '여', '뇨': '요' };

        async function main() {
            try {
                app = initializeApp(firebaseConfig);
                db = getFirestore(app);
                auth = getAuth(app);
                onAuthStateChanged(auth, (user) => {
                    if (user) { userId = user.uid; showLobby(); } else { signInAnonymously(auth); }
                });
            } catch (error) {
                console.error("Firebase 초기화 오류:", error);
                allDOMElements.loadingScreen.textContent = "오류가 발생했습니다.";
            }
        }

        function showLobby() {
            allDOMElements.loadingScreen.classList.add('hidden');
            allDOMElements.gameScreen.classList.add('hidden');
            allDOMElements.lobbyScreen.classList.remove('hidden');
            listenToPublicRooms();
        }

        function showGame(roomId) {
            allDOMElements.lobbyScreen.classList.add('hidden');
            allDOMElements.gameScreen.classList.remove('hidden');
            allDOMElements.roomNameDisplay.textContent = roomId;
        }

        function listenToPublicRooms() {
            if (unsubscribeRooms) unsubscribeRooms();
            const roomsRef = collection(db, `artifacts/${appId}/public/data/games`);
            const q = query(roomsRef, where("status", "==", "waiting"));

            unsubscribeRooms = onSnapshot(q, (querySnapshot) => {
                allDOMElements.publicRoomsList.innerHTML = '';
                if (querySnapshot.empty) {
                    allDOMElements.publicRoomsList.innerHTML = `<p class="text-gray-500 text-center">참여할 수 있는 방이 없습니다.</p>`;
                }
                querySnapshot.forEach((docSnap) => {
                    const room = docSnap.data();
                    const roomEl = document.createElement('div');
                    roomEl.className = 'p-4 bg-white rounded-lg shadow flex justify-between items-center cursor-pointer hover:bg-gray-50';
                    roomEl.dataset.roomId = docSnap.id;
                    roomEl.dataset.passwordProtected = !!room.password;
                    
                    roomEl.innerHTML = `
                        <div>
                            <p class="font-bold text-lg">${docSnap.id}</p>
                            <p class="text-sm text-gray-600">${Object.keys(room.players || {}).length} / ${room.maxPlayers} 명</p>
                        </div>
                        ${room.password ? '<span>🔒</span>' : ''}
                    `;
                    allDOMElements.publicRoomsList.appendChild(roomEl);
                });
            });
        }

        async function createRoom(nickname, roomName, password, maxPlayers) {
            if (!nickname || !roomName) return alert("닉네임과 방 이름을 모두 입력해주세요.");
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, roomName);
            if ((await getDoc(gameDocRef)).exists()) return alert("이미 존재하는 방 이름입니다.");

            await setDoc(gameDocRef, {
                creatorUid: userId, players: { [userId]: { nickname } },
                words: [], lastWord: "", currentPlayerUid: null, turnOrder: [],
                status: 'waiting', isPublic: !password, password: password || null,
                turnStartTime: serverTimestamp(), maxPlayers: parseInt(maxPlayers, 10),
            });
            startListeningToGame(gameDocRef, roomName);
        }

        async function joinRoom(roomId, nickname, passwordAttempt = null) {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, roomId);
            const docSnap = await getDoc(gameDocRef);
            if (!docSnap.exists()) return alert("존재하지 않는 방입니다.");

            const gameData = docSnap.data();
            if (gameData.password && gameData.password !== passwordAttempt) return alert("비밀번호가 틀렸습니다.");
            
            const playerCount = Object.keys(gameData.players || {}).length;
            if (playerCount >= gameData.maxPlayers && !gameData.players[userId]) return alert("방이 가득 찼습니다.");
            
            const updateData = { [`players.${userId}`]: { nickname } };
            const newPlayerCount = playerCount + (gameData.players[userId] ? 0 : 1);

            if (newPlayerCount === gameData.maxPlayers) {
                const playerIds = [...Object.keys(gameData.players || {}), userId];
                const shuffledPlayerIds = playerIds.sort(() => Math.random() - 0.5);
                updateData.status = 'playing';
                updateData.turnOrder = shuffledPlayerIds;
                updateData.currentPlayerUid = shuffledPlayerIds[0];
                updateData.turnStartTime = serverTimestamp();
            }
            
            await updateDoc(gameDocRef, updateData);
            allDOMElements.passwordModal.classList.add('hidden');
            startListeningToGame(gameDocRef, roomId);
        }

        function startListeningToGame(gameDocRef, roomId) {
            if (unsubscribeRooms) unsubscribeRooms();
            if (unsubscribeGame) unsubscribeGame();
            currentGameId = roomId;

            unsubscribeGame = onSnapshot(gameDocRef, (docSnap) => {
                if (docSnap.exists()) { updateUI(docSnap.data()); } 
                else { alert("방이 삭제되었습니다."); leaveRoom(true); }
            });
            showGame(roomId);
        }
        
        async function leaveRoom(isKicked = false) {
            const roomId = currentGameId;
            if (unsubscribeGame) unsubscribeGame();
            unsubscribeGame = null;
            currentGameId = null;
            if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }
            
            if (roomId && !isKicked) {
                try {
                    const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, roomId);
                    const docSnap = await getDoc(gameDocRef);
                    if (docSnap.exists()) {
                        const gameData = docSnap.data();
                        const players = { ...(gameData.players || {}) };
                        const turnOrder = gameData.turnOrder || [];
                        const creatorUid = gameData.creatorUid;
                        const currentPlayerUid = gameData.currentPlayerUid;
                        const leavingPlayerIndex = turnOrder.indexOf(userId);
                        
                        // 1) 플레이어 제거
                        delete players[userId];
                        const newTurnOrder = turnOrder.filter(p => p !== userId);

                        // 2) 방에 아무도 없으면 삭제
                        if (Object.keys(players).length === 0) {
                            await deleteDoc(gameDocRef);
                        } else {
                            // 3) 다음 턴자 결정: 만약 떠나는 사람이 현재 턴이면 다음 사람으로 옮김
                            let nextPlayerUid = currentPlayerUid;
                            if (currentPlayerUid === userId) {
                                if (newTurnOrder.length > 0) {
                                    nextPlayerUid = newTurnOrder[leavingPlayerIndex % newTurnOrder.length];
                                } else {
                                    nextPlayerUid = Object.keys(players)[0];
                                }
                            }

                            // 4) 방장 떠남 처리: 방장 uid를 새 플레이어로 지정 (간단하게 첫 플레이어)
                            let newCreator = creatorUid;
                            if (creatorUid === userId) {
                                newCreator = Object.keys(players)[0];
                            }

                            await updateDoc(gameDocRef, { 
                                players, 
                                turnOrder: newTurnOrder,
                                creatorUid: newCreator,
                                status: 'waiting', 
                                words: [], 
                                lastWord: "", 
                                currentPlayerUid: nextPlayerUid
                            });
                        }
                    }
                } catch (error) { console.error("Error leaving room:", error); }
            }
            showLobby();
        }

        function updateUI(gameData) {
            if (!gameData) return;
            const { players = {}, currentPlayerUid, words = [], lastWord = "", status, creatorUid, turnOrder = [], turnStartTime, winner, maxPlayers } = gameData;
            
            allDOMElements.deleteRoomBtn.classList.toggle('hidden', creatorUid !== userId);
            updatePlayerList(players, turnOrder, currentPlayerUid);

            const canStart = creatorUid === userId && Object.keys(players).length >= 2;
            allDOMElements.startGameBtn.classList.toggle('hidden', !canStart || status === 'playing');

            if (status === 'waiting') {
                allDOMElements.turnInfoEl.textContent = `상대방을 기다리는 중입니다... (${Object.keys(players).length}/${maxPlayers})`;
                allDOMElements.lastWordEl.textContent = "대기중";
                allDOMElements.timerDisplay.textContent = TURN_DURATION;
                allDOMElements.wordInput.disabled = true;
                allDOMElements.sendBtn.disabled = true;
                allDOMElements.forfeitBtn.disabled = true;
                allDOMElements.resetGameBtn.disabled = true;
                return;
            }
            
            const isMyTurn = currentPlayerUid === userId;
            allDOMElements.wordListEl.innerHTML = '';
            words.forEach(item => {
                const li = document.createElement('li');
                const nickname = players[item.player]?.nickname || '알수없음';
                const isMyMessage = item.player === userId;
                li.className = `p-3 rounded-lg ${isMyMessage ? 'bg-blue-50 text-right' : 'bg-green-50 text-left'}`;
                li.innerHTML = `<span class="font-bold ${isMyMessage ? 'text-blue-600' : 'text-green-600'}">${nickname}</span>: <span class="text-xl text-gray-800">${item.word}</span>`;
                allDOMElements.wordListEl.appendChild(li);
            });
            allDOMElements.wordListEl.scrollTop = allDOMElements.wordListEl.scrollHeight;
            
            if (timerInterval) { clearInterval(timerInterval); timerInterval = null; }

            if (status === 'finished') {
                const winnerNickname = players[winner.uid]?.nickname;
                allDOMElements.turnInfoEl.textContent = `${winnerNickname}님의 승리! (${winner.reason})`;
                allDOMElements.lastWordEl.textContent = "게임 종료";
                allDOMElements.wordInput.disabled = true;
                allDOMElements.sendBtn.disabled = true;
                allDOMElements.forfeitBtn.disabled = true;
                allDOMElements.resetGameBtn.disabled = !(creatorUid === userId);
                allDOMElements.resetGameBtn.textContent = "다시 하기";
                return;
            }

            const currentPlayerNickname = players[currentPlayerUid]?.nickname;
            allDOMElements.forfeitBtn.disabled = false;
            allDOMElements.resetGameBtn.disabled = true;
            allDOMElements.resetGameBtn.textContent = "게임 초기화";

            if (words.length === 0) {
                allDOMElements.lastWordEl.textContent = "게임 시작!";
                allDOMElements.turnInfoEl.textContent = isMyTurn ? `${players[userId].nickname}님, 첫 단어를 제시해주세요!` : `${currentPlayerNickname}님이 첫 단어를 제시합니다...`;
            } else {
                allDOMElements.lastWordEl.textContent = lastWord;
                allDOMElements.turnInfoEl.textContent = isMyTurn ? `${players[userId].nickname}님 차례입니다!` : `${currentPlayerNickname}님 차례입니다...`;
            }
            allDOMElements.wordInput.disabled = !isMyTurn;
            allDOMElements.sendBtn.disabled = !isMyTurn;
            if (isMyTurn) {
                // 포커스 시도 (비활성화 상태가 아닐 때만)
                setTimeout(() => { 
                    try { allDOMElements.wordInput.focus(); } catch(e) { /* ignore */ } 
                }, 50);
            }

            if(turnStartTime && turnStartTime.toDate) {
                const startTime = turnStartTime.toDate().getTime();
                timerInterval = setInterval(async () => {
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    const remaining = TURN_DURATION - elapsed;
                    allDOMElements.timerDisplay.textContent = remaining >= 0 ? remaining : 0;
                    if (remaining < 0 && isMyTurn) {
                        clearInterval(timerInterval);
                        const otherPlayers = Object.keys(players).filter(p => p !== userId);
                        const winnerUid = otherPlayers.length >= 1 ? otherPlayers[0] : userId;
                        await endGame(winnerUid, "시간 초과");
                    }
                }, 1000);
            }
        }
        
        function updatePlayerList(players, turnOrder, currentPlayerUid) {
             allDOMElements.playerList.innerHTML = '';
            const playerIdsInTurnOrder = turnOrder && turnOrder.length > 0 ? turnOrder : Object.keys(players);
            playerIdsInTurnOrder.forEach(pid => {
                if (!players[pid]) return;
                const li = document.createElement('li');
                const isCurrent = pid === currentPlayerUid;
                li.className = `p-2 rounded-md truncate ${isCurrent ? 'bg-blue-100 font-bold text-blue-700' : 'bg-gray-100'}`;
                li.textContent = players[pid]?.nickname || '...';
                allDOMElements.playerList.appendChild(li);
            });
        }
        
        async function endGame(winnerUid, reason) {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            await updateDoc(gameDocRef, { status: 'finished', winner: { uid: winnerUid, reason: reason } });
        }
        
        async function handleSendWord() {
            const word = allDOMElements.wordInput.value.trim();
            if (!word || word.length < 2) return alert("두 글자 이상의 단어를 입력해주세요.");
            allDOMElements.sendBtn.disabled = true;

            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            const gameDoc = await getDoc(gameDocRef);

            if (gameDoc.exists()) {
                const gameData = gameDoc.data();
                const { words = [], lastWord = "", turnOrder = [] } = gameData;
                const lastChar = lastWord.charAt(lastWord.length - 1);
                const firstChar = word.charAt(0);

                const isValidDueum = dueumMap[lastChar] === firstChar;
                if (words.length > 0 && lastChar !== firstChar && !isValidDueum) {
                    allDOMElements.sendBtn.disabled = false;
                    return alert("이전 단어의 마지막 글자로 시작해야 합니다.");
                }
                if (words.some(item => item.word === word)) {
                    allDOMElements.sendBtn.disabled = false;
                    return alert("이미 사용된 단어입니다.");
                }
                const isValidWord = await isRealWord(word);
                if (!isValidWord) {
                    allDOMElements.sendBtn.disabled = false;
                    return alert(`'${word}'는 사전에 없는 단어입니다.`);
                }

                const currentIndex = turnOrder.indexOf(userId);
                const nextIndex = (currentIndex + 1) % turnOrder.length;
                const nextPlayerUid = turnOrder[nextIndex];
                
                await updateDoc(gameDocRef, {
                    words: [...words, { player: userId, word: word }],
                    lastWord: word,
                    currentPlayerUid: nextPlayerUid,
                    turnStartTime: serverTimestamp()
                });
                allDOMElements.wordInput.value = '';
            }
            allDOMElements.sendBtn.disabled = false;
        }

        // (주의) 실제 배포 시에는 API 키를 안전하게 관리하세요.
        async function isRealWord(word) {
            // 외부 API 사용 부분은 임시로 true를 반환하도록 두었습니다.
            // 실제로 표준국어대사전 등과 연동하려면 서버 측에서 API 호출을 구현하세요.
            return true;
        }

        // --- IME 조합 문제 해결: composition 이벤트 처리 ---
        (function setupCompositionSafeInput() {
            const input = allDOMElements.wordInput;
            let composing = false;
            input.addEventListener('compositionstart', () => { composing = true; });
            input.addEventListener('compositionend', (e) => {
                composing = false;
                // 조합이 끝난 뒤 필터링 적용 (한글과 공백만 허용)
                e.target.value = e.target.value.replace(/[^가-힣\s]/g, '');
            });
            input.addEventListener('input', (e) => {
                // 조합 중이면 필터링을 적용하지 않음 -> IME 입력이 정상적으로 보임
                if (composing) return;
                e.target.value = e.target.value.replace(/[^가-힣\s]/g, '');
            });
        })();

        allDOMElements.openCreateRoomModalBtn.addEventListener('click', () => allDOMElements.createRoomModal.classList.remove('hidden'));
        allDOMElements.cancelCreateBtn.addEventListener('click', () => allDOMElements.createRoomModal.classList.add('hidden'));
        allDOMElements.confirmCreateBtn.addEventListener('click', () => {
            createRoom(
                allDOMElements.nicknameInput.value.trim(), 
                allDOMElements.roomNameInput.value.trim(), 
                allDOMElements.passwordInput.value.trim(),
                allDOMElements.maxPlayersInput.value
            );
            allDOMElements.createRoomModal.classList.add('hidden');
        });
        
        allDOMElements.publicRoomsList.addEventListener('click', (e) => {
            const roomEl = e.target.closest('[data-room-id]');
            if (!roomEl) return;
            const { roomId, passwordProtected } = roomEl.dataset;
            allDOMElements.passwordModal.dataset.roomId = roomId;
            if (passwordProtected === 'true') {
                allDOMElements.joinNicknameInput.value = '';
                allDOMElements.joinPasswordInput.value = '';
                allDOMElements.passwordModal.classList.remove('hidden');
            } else {
                const nickname = prompt("사용할 닉네임을 입력하세요:");
                if(nickname) joinRoom(roomId, nickname);
            }
        });
        
        allDOMElements.cancelJoinBtn.addEventListener('click', () => allDOMElements.passwordModal.classList.add('hidden'));
        allDOMElements.confirmJoinBtn.addEventListener('click', () => {
            const roomId = allDOMElements.passwordModal.dataset.roomId;
            const nickname = allDOMElements.joinNicknameInput.value.trim();
            const password = allDOMElements.joinPasswordInput.value.trim();
            if(nickname) joinRoom(roomId, nickname, password);
        });

        allDOMElements.leaveRoomBtn.addEventListener('click', () => leaveRoom(false));
        allDOMElements.deleteRoomBtn.addEventListener('click', async () => {
            if (confirm("정말로 이 방을 삭제하시겠습니까?")) {
                await deleteDoc(doc(db, `artifacts/${appId}/public/data/games`, currentGameId));
            }
        });
        
        allDOMElements.sendBtn.addEventListener('click', handleSendWord);
        allDOMElements.wordInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') handleSendWord(); });
        
        allDOMElements.forfeitBtn.addEventListener('click', async () => {
            if (confirm("정말로 항복하시겠습니까?")) {
                const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
                const gameDoc = await getDoc(gameDocRef);
                if(gameDoc.exists()) {
                    const otherPlayers = Object.keys(gameDoc.data().players || {}).filter(p => p !== userId);
                    if (otherPlayers.length > 0) {
                        await endGame(otherPlayers[0], "항복");
                    }
                }
            }
        });
        
        allDOMElements.resetGameBtn.addEventListener('click', async () => {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            const gameDoc = await getDoc(gameDocRef);
            if(gameDoc.exists()){
                const gameData = gameDoc.data();
                if (gameData.creatorUid !== userId) return alert("방장만 게임을 다시 시작할 수 있습니다.");
                if (gameData.status !== 'finished') {
                    if (!confirm("게임이 진행중입니다. 정말로 초기화하시겠습니까?")) return;
                }
                const playerIds = Object.keys(gameData.players || {});
                const shuffledPlayerIds = playerIds.sort(() => Math.random() - 0.5);
                await updateDoc(gameDocRef, {
                    words: [], lastWord: "", status: 'playing',
                    turnOrder: shuffledPlayerIds,
                    currentPlayerUid: shuffledPlayerIds[0],
                    turnStartTime: serverTimestamp(),
                    winner: null
                });
            }
        });

        allDOMElements.startGameBtn.addEventListener('click', async () => {
            const gameDocRef = doc(db, `artifacts/${appId}/public/data/games`, currentGameId);
            const docSnap = await getDoc(gameDocRef);
            if (docSnap.exists()) {
                const gameData = docSnap.data();
                const playerIds = Object.keys(gameData.players || {});
                const shuffledPlayerIds = playerIds.sort(() => Math.random() - 0.5);
                await updateDoc(gameDocRef, {
                    status: 'playing',
                    turnOrder: shuffledPlayerIds,
                    currentPlayerUid: shuffledPlayerIds[0],
                    turnStartTime: serverTimestamp()
                });
            }
        });

        main();
    </script>
</body>
</html>
